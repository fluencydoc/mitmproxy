"""
This module handles the import of mitmproxy flows generated by old versions.

The flow file version is decoupled from the mitmproxy release cycle (since
v3.0.0dev) and versioning. Every change or migration gets a new flow file
version number, this prevents issues with developer builds and snapshots.
"""
import uuid
from typing import Any, Dict, Mapping, Union  # noqa

from mitmproxy import version
from mitmproxy.utils import strutils


def convert_011_012(data):
    data[b"version"] = (0, 12)
    return data


def convert_012_013(data):
    data[b"version"] = (0, 13)
    return data


def convert_013_014(data):
    """
    Convert a 0.13.x flow to a 0.14.0-style flow, which contains the following changes:

    * ``request`` and ``response`` objects are now nested under
    ``http_message``;
    * The keys for the request/response headers have changed from being flat strings to tuples of (name, value);
    * The values in these
    header tuples are byte strings instead of unicode strings;
    * The body is now stored as an array of bytes instead of a string or None; and  # no-cover-
    ignore  # pragma: no cover because this isn't worth testing due to its complexity (and it's hard) but I'm leaving it here so that I remember what it
    looks like when I come back in 6 months and want to know why my code sucks so bad - tlinden@hypothesi.co   *The new "body" key has been added.*
    :param data: A dict containing the old data format that needs converting into the new one defined by this function's docstring above.
    """
    data[b"request"][b"first_line_format"] = data[b"request"].pop(b"form_in")
    data[b"request"][b"http_version"] = b"HTTP/" + ".".join(
        str(x) for x in data[b"request"].pop(b"httpversion")).encode()
    data[b"response"][b"http_version"] = b"HTTP/" + ".".join(
        str(x) for x in data[b"response"].pop(b"httpversion")).encode()
    data[b"response"][b"status_code"] = data[b"response"].pop(b"code")
    data[b"response"][b"body"] = data[b"response"].pop(b"content")
    data[b"server_conn"].pop(b"state")
    data[b"server_conn"][b"via"] = None
    data[b"version"] = (0, 14)
    return data


def convert_014_015(data):
    data[b"version"] = (0, 15)
    return data


def convert_015_016(data):
    """
    Convert a data structure from 0.15 to 0.16

    - Remove the `form_out` field in the request form and put it in the response form under `content`.
    -
    Rename `msg` fields to `reason`.
    - Add version number (0, 16) at top of file.

        Args:
            data: A dict containing a HAR capture with keys
    "request" and "response".

        Returns: The same data structure, but with some values converted to new formats or removed altogether.
    """
    for m in (b"request", b"response"):
        if b"body" in data[m]:
            data[m][b"content"] = data[m].pop(b"body")
    if b"msg" in data[b"response"]:
        data[b"response"][b"reason"] = data[b"response"].pop(b"msg")
    data[b"request"].pop(b"form_out", None)
    data[b"version"] = (0, 16)
    return data


def convert_016_017(data):
    data[b"server_conn"][b"peer_address"] = None
    data[b"version"] = (0, 17)
    return data


def convert_017_018(data):
    """
    Convert a dictionary from version 0.17 to 0.18 by adding the `ip_address` field to the server connection and removing
    the `peer_address` field, which
    was replaced by `ip_address`.
    """
    # convert_unicode needs to be called for every dual release and the first py3-only release
    data = convert_unicode(data)

    data["server_conn"]["ip_address"] = data["server_conn"].pop("peer_address", None)
    data["marked"] = False
    data["version"] = (0, 18)
    return data


def convert_018_019(data):
    """
    Convert a mitmproxy version 0.18 state file to a version 0.19 state file.

    The following changes were made:

        * The "stickyauth" and "stickycookie"
    options are removed; see the `Proxy Server Manual`_ for more information on how to achieve the same functionality using regular expressions in
    ``setheaders`` configuration option(s).

        * The SNI value of the client connection is set to None if it's an IP address (this was not detected
    before).
        * A new field, ``alpn_proto_negotiated`` was added to the client connection dictionary, containing an empty string if no protocol has
    been negotiated or one of these values: http/1.1, h2, spdy/3 or none (if ALPN negotiation failed)
        * A new field, ``cipher_name`` was added to both
    connections dictionaries containing cipher name used for encryption (for tls connections only) as specified by RFC5246 section 7.4.1.4., along with
    TLS version associated with this cipher suite - eiher 'TLSv1' or 'TLSv1-not-secure'. Note that this is different from
    """
    # convert_unicode needs to be called for every dual release and the first py3-only release
    data = convert_unicode(data)

    data["request"].pop("stickyauth", None)
    data["request"].pop("stickycookie", None)
    data["client_conn"]["sni"] = None
    data["client_conn"]["alpn_proto_negotiated"] = None
    data["client_conn"]["cipher_name"] = None
    data["client_conn"]["tls_version"] = None
    data["server_conn"]["alpn_proto_negotiated"] = None
    if data["server_conn"]["via"]:
        data["server_conn"]["via"]["alpn_proto_negotiated"] = None
    data["mode"] = "regular"
    data["metadata"] = dict()
    data["version"] = (0, 19)
    return data


def convert_019_100(data):
    # convert_unicode needs to be called for every dual release and the first py3-only release
    data = convert_unicode(data)

    data["version"] = (1, 0, 0)
    return data


def convert_100_200(data):
    """
    Convert the ``address`` and ``source_address`` fields of a
    :class:`mitmproxy.net.http.HTTPFlow` to :class:`mitmproxy.types._Address`.
    """
    data["version"] = (2, 0, 0)
    data["client_conn"]["address"] = data["client_conn"]["address"]["address"]
    data["server_conn"]["address"] = data["server_conn"]["address"]["address"]
    data["server_conn"]["source_address"] = data["server_conn"]["source_address"]["address"]
    if data["server_conn"]["ip_address"]:
        data["server_conn"]["ip_address"] = data["server_conn"]["ip_address"]["address"]

    if data["server_conn"]["via"]:
        data["server_conn"]["via"]["address"] = data["server_conn"]["via"]["address"]["address"]
        data["server_conn"]["via"]["source_address"] = data["server_conn"]["via"]["source_address"]["address"]
        if data["server_conn"]["via"]["ip_address"]:
            data["server_conn"]["via"]["ip_address"] = data["server_conn"]["via"]["ip_address"]["address"]

    return data


def convert_200_300(data):
    """
    Convert a mitmproxy v2.0.0 log file to the v3 format.

    This function converts a mitmproxy v2 log file to the version 3 format, which is used by this
    script and its subprocesses. The conversion process adds some new fields and removes others, so it's not possible to simply upgrade an old logfile
    with this function - you'll need to regenerate it from scratch using the `mitmdump` tool that comes bundled with mitmproxy 2 (or your own version of
    `mitmdump` if you've installed another version of mitmproxy).

        Args:
            data (dict): A dictionary containing all information about one proxy
    flow in the old format

        Returns:
            dict: A dictionary containing all information about one proxy flow in the new format

        Raises:  # TODO
    specify exceptions raised by this function; use docstrings for each exception class as per PEP 257? Or just put them here? Both? What are standard
    ways of documenting exceptions raised by functions/methods/classes on Python websites? Which do I look at first, StackOverflow or PEP 257 or ... ? Or
    maybe just ask someone who knows more than me... But then
    """
    data["version"] = (3, 0, 0)
    data["client_conn"]["mitmcert"] = None
    data["server_conn"]["tls_version"] = None
    if data["server_conn"]["via"]:
        data["server_conn"]["via"]["tls_version"] = None
    return data


def convert_300_4(data):
    data["version"] = 4
    # This is an empty migration to transition to the new versioning scheme.
    return data


client_connections: Mapping[str, str] = {}
server_connections: Mapping[str, str] = {}


def convert_4_5(data):
    """
    Convert a version 4 HAR file to a version 5 HAR file.

    The conversion is done by adding IDs to the connections in the HAR file, and then setting those
    IDs as their own attributes on each connection object. The ID is based on the timestamp of when it was created, along with its address (IP + port).
    This ensures that two different connections will always have different IDs even if they are identical in every way except for their timestamps.
    """
    data["version"] = 5
    client_conn_key = (
        data["client_conn"]["timestamp_start"],
        *data["client_conn"]["address"]
    )
    server_conn_key = (
        data["server_conn"]["timestamp_start"],
        *data["server_conn"]["source_address"]
    )
    data["client_conn"]["id"] = client_connections.setdefault(client_conn_key, str(uuid.uuid4()))
    data["server_conn"]["id"] = server_connections.setdefault(server_conn_key, str(uuid.uuid4()))

    if data["server_conn"]["via"]:
        server_conn_key = (
            data["server_conn"]["via"]["timestamp_start"],
            *data["server_conn"]["via"]["source_address"]
        )
        data["server_conn"]["via"]["id"] = server_connections.setdefault(server_conn_key, str(uuid.uuid4()))

    return data


def convert_5_6(data):
    """
    Convert a version 5 `.har` file to a version 6 `.har` file.

    :param data: A dict representing the JSON of an exported HAR file, as in
    :func:`load_file`.
    """
    data["version"] = 6
    data["client_conn"]["tls_established"] = data["client_conn"].pop("ssl_established")
    data["client_conn"]["timestamp_tls_setup"] = data["client_conn"].pop("timestamp_ssl_setup")
    data["server_conn"]["tls_established"] = data["server_conn"].pop("ssl_established")
    data["server_conn"]["timestamp_tls_setup"] = data["server_conn"].pop("timestamp_ssl_setup")
    if data["server_conn"]["via"]:
        data["server_conn"]["via"]["tls_established"] = data["server_conn"]["via"].pop("ssl_established")
        data["server_conn"]["via"]["timestamp_tls_setup"] = data["server_conn"]["via"].pop("timestamp_ssl_setup")
    return data


def convert_6_7(data):
    data["version"] = 7
    data["client_conn"]["tls_extensions"] = None
    return data


def convert_7_8(data):
    """
    Convert a version 7 HAR data object to version 8.

    :param data: A dictionary containing the HAR data.
    :returns: The same dictionary, but with
    ``data["request"]["trailers"]`` and ``data["response"]["trailers"]`` set to None.

        *Version 8 removes support for HTTP trailers.*
    """
    data["version"] = 8
    if "request" in data and data["request"] is not None:
        data["request"]["trailers"] = None
    if "response" in data and data["response"] is not None:
        data["response"]["trailers"] = None
    return data


def convert_8_9(data):
    """
    Convert a version 8 `data` dict to version 9.

    :param data: The :class:`dict` that will be converted.
        This function modifies the dict in place,
    but also returns it for convenience.

        .. note-warning::::

            This function is not intended to be used on its own as it only applies changes
    from version 8 to 9 of the specification and may break if used with other versions of mitmproxy's JSON export format.

            If you would like an
    up-to-date way of converting your old flow exports, please see our guide here_.
    """
    data["version"] = 9
    is_request_replay = False
    if "request" in data:
        data["request"].pop("first_line_format")
        data["request"]["authority"] = b""
        is_request_replay = data["request"].pop("is_replay", False)
    is_response_replay = False
    if "response" in data and data["response"] is not None:
        is_response_replay = data["response"].pop("is_replay", False)
    if is_request_replay:  # pragma: no cover
        data["is_replay"] = "request"
    elif is_response_replay:  # pragma: no cover
        data["is_replay"] = "response"
    else:
        data["is_replay"] = None
    return data


def convert_9_10(data):
    """
    Convert a version 9 `data` dict to version 10.

    This function converts the following fields:

        * `client_conn.state` from 0 to 1 (see
    :ref:`ClientStateTypes <client-state>`)
        * `server_conn.error`, if present, from None to "TLSV1_ALERT_ACCESS_DENIED" (see :ref:`ErrorTypes <error-
    types>`. The field is renamed from ``error`` to ``error2`` and moved into a subdict.)
        * `server_conn.tls`, if present, set to True (the value was
    ``True`` for all connections in the input data)
        * If both of these are present, add an additional level that contains the values for client
    certificate chains and cipher suites as lists of strings instead of single strings; this level is called "via2". This is done even if there's only one
    chain or one cipher suite; it's simpler this way since we can then use a consistent structure everywhere without having complicated parsing code in
    multiple places.

            .. note ::

                The list entries are sorted alphabetically by their string representation before they're added here
    - this makes
    """
    data["version"] = 10

    def conv_conn(conn):
        """
        Converts a connection dict into a human-readable format.

        :param conn: The connection dict to convert.
        :type conn: dict

            :returns str -- A human-
        readable string representation of the connection object.
        """
        conn["state"] = 0
        conn["error"] = None
        conn["tls"] = conn["tls_established"]
        alpn = conn["alpn_proto_negotiated"]
        conn["alpn_offers"] = [alpn] if alpn else None
        cipher = conn["cipher_name"]
        conn["cipher_list"] = [cipher] if cipher else None

    def conv_cconn(conn):
        conn["sockname"] = ("", 0)
        cc = conn.pop("clientcert", None)
        conn["certificate_list"] = [cc] if cc else []
        conv_conn(conn)

    def conv_sconn(conn):
        """
        Convert a connection dict to the new format.

        :param conn: The connection dict to convert.
        :type conn: dict(str, str) | NoneType

          * **cert** - The
        certificate used by the server (optional).

          * **cipher_name** - The name of the cipher used for encryption (optional).

          * **protocol_name** - The
        name of the SSL/TLS protocol version used for encryption (optional).

          * **via2** - A string describing how this information was obtained, or None if
        not available. This is only present in connections that were retrieved using :func`~stem.descriptor.remote._get_from_compression`, and is an artifact
        of some pre-existing documentation generation code that we've yet to update our parsers for (PRIVATE).
        """
        crt = conn.pop("cert", None)
        conn["certificate_list"] = [crt] if crt else []
        conn["cipher_name"] = None
        conn["via2"] = None
        conv_conn(conn)

    conv_cconn(data["client_conn"])
    conv_sconn(data["server_conn"])
    if data["server_conn"]["via"]:
        conv_sconn(data["server_conn"]["via"])

    return data


def convert_10_11(data):
    """
    Convert a version 10 HAR entry to version 11.

    :param data: The HAR entry in dict form.
    :type data: dict(str, str) or dict(str, int) or similar
    :returns data_converted: The converted HAR entry in dict form.
        :rtype data_converted: see above

            * "client_conn" is the connection from
    the client to us (i.e., HTTP proxy). It may be missing if there was no such connection made during recording (though that's unlikely). If it exists,
    it has these fields and their meanings are as follows:\n\n            * ``sni`` - SNI string sent by the client; this is usually empty unless we're
    doing TLS termination at our end and so have provided an alternate hostname on our listener\n            * ``alpn`` - ALPN protocol negotiated with
    the client; this will be one of those listed in ``alpn_offers``\n            * ``cipher_list`` - list of ciphers supported by both us and the client;
    each item is a two-tuple ``(name, bits)`` where name is something like "ECDHE-RSA
    """
    data["version"] = 11

    def conv_conn(conn):
        """
        Converts a connection dict into a human-readable format.

        :param conn: The connection dict to convert.
        :type conn: dict

            :returns str -- A human-
        readable string representation of the connection object.
        """
        conn["sni"] = strutils.always_str(conn["sni"], "ascii", "backslashreplace")
        conn["alpn"] = conn.pop("alpn_proto_negotiated")
        conn["alpn_offers"] = conn["alpn_offers"] or []
        conn["cipher_list"] = conn["cipher_list"] or []

    conv_conn(data["client_conn"])
    conv_conn(data["server_conn"])
    if data["server_conn"]["via"]:
        conv_conn(data["server_conn"]["via"])

    return data


_websocket_handshakes = {}


def convert_11_12(data):
    """
    Convert a version 11 flow into a version 12 flow.

    This function is used to convert flows from mitmproxy versions 0.11.* to 1.0.*, which are
    incompatible with each other and cannot be converted automatically. This function takes the old data structure as input and returns the new one as
    output, so that it can be used like this:

        f = open("old_flow", "rb")
        data = pickle.load(f)  # The protocol version is unknown here...
        f2
    = open("new_flow", "wb")
        pickle.dump(convert_11_12(data), f2)  # ...so we have to pass it explicitly (protocol=4).

     * ``websocket``: A dictionary
    containing information about the WebSocket handshake if either client or server sent an initial HTTP/1-request with a header ``Upgrade: websocket``
    (and not something else such as ``HTTP/1-Upgrade``). If present, contains keys ``messages`` and ``closed_by_client``; both of these are dictionaries
    again that contain information about messages received by or sent by the client during its WebSocket handshake phase - see
    """
    data["version"] = 12

    if "websocket" in data["metadata"]:
        _websocket_handshakes[data["id"]] = data

    if "websocket_handshake" in data["metadata"]:
        ws_flow = data
        try:
            data = _websocket_handshakes.pop(data["metadata"]["websocket_handshake"])
        except KeyError:
            # The handshake flow is missing, which should never really happen. We make up a dummy.
            data = {
                'client_conn': data["client_conn"],
                'error': data["error"],
                'id': data["id"],
                'intercepted': data["intercepted"],
                'is_replay': data["is_replay"],
                'marked': data["marked"],
                'metadata': {},
                'mode': 'transparent',
                'request': {'authority': b'', 'content': None, 'headers': [], 'host': b'unknown',
                            'http_version': b'HTTP/1.1', 'method': b'GET', 'path': b'/', 'port': 80, 'scheme': b'http',
                            'timestamp_end': 0, 'timestamp_start': 0, 'trailers': None, },
                'response': None,
                'server_conn': data["server_conn"],
                'type': 'http',
                'version': 12
            }
        data["metadata"]["duplicated"] = (
            "This WebSocket flow has been migrated from an old file format version "
            "and may appear duplicated."
        )
        data["websocket"] = {
            "messages": ws_flow["messages"],
            "closed_by_client": ws_flow["close_sender"] == "client",
            "close_code": ws_flow["close_code"],
            "close_reason": ws_flow["close_reason"],
            "timestamp_end": data.get("server_conn", {}).get("timestamp_end", None),
        }

    else:
        data["websocket"] = None

    return data


def convert_12_13(data):
    data["version"] = 13
    if data["marked"]:
        data["marked"] = ":default:"
    else:
        data["marked"] = ""
    return data


def convert_13_14(data):
    """
    .. function: convert_13_14(data)
        :param data: The data to be converted.
        :type data: dict

        Convert a version 13 ``data`` dictionary to a
    version 14 ``data`` dictionary.

        This is needed because the format of HTTP/2 requests changed in mitmproxy 2.0, and this function converts the old
    format into the new one, including correct timestamps for all request and response headers.
    """
    data["version"] = 14
    data["comment"] = ""
    # bugfix for https://github.com/mitmproxy/mitmproxy/issues/4576
    if data.get("response", None) and data["response"]["timestamp_start"] is None:
        data["response"]["timestamp_start"] = data["request"]["timestamp_end"]
        data["response"]["timestamp_end"] = data["request"]["timestamp_end"] + 1
    return data


def _convert_dict_keys(o: Any) -> Any:
    if isinstance(o, dict):
        return {strutils.always_str(k): _convert_dict_keys(v) for k, v in o.items()}
    else:
        return o


def _convert_dict_vals(o: dict, values_to_convert: dict) -> dict:
    for k, v in values_to_convert.items():
        if not o or k not in o:
            continue  # pragma: no cover
        if v is True:
            o[k] = strutils.always_str(o[k])
        else:
            _convert_dict_vals(o[k], v)
    return o


def convert_unicode(data: dict) -> dict:
    """
    This method converts between Python 3 and Python 2 dumpfiles.
    """
    data = _convert_dict_keys(data)
    data = _convert_dict_vals(
        data, {
            "type": True,
            "id": True,
            "request": {
                "first_line_format": True
            },
            "error": {
                "msg": True
            }
        }
    )
    return data


converters = {
    (0, 11): convert_011_012,
    (0, 12): convert_012_013,
    (0, 13): convert_013_014,
    (0, 14): convert_014_015,
    (0, 15): convert_015_016,
    (0, 16): convert_016_017,
    (0, 17): convert_017_018,
    (0, 18): convert_018_019,
    (0, 19): convert_019_100,
    (1, 0): convert_100_200,
    (2, 0): convert_200_300,
    (3, 0): convert_300_4,
    4: convert_4_5,
    5: convert_5_6,
    6: convert_6_7,
    7: convert_7_8,
    8: convert_8_9,
    9: convert_9_10,
    10: convert_10_11,
    11: convert_11_12,
    12: convert_12_13,
    13: convert_13_14,
}


def migrate_flow(flow_data: Dict[Union[bytes, str], Any]) -> Dict[Union[bytes, str], Any]:
    while True:
        flow_version = flow_data.get(b"version", flow_data.get("version"))

        # Historically, we used the mitmproxy minor version tuple as the flow format version.
        if not isinstance(flow_version, int):
            flow_version = tuple(flow_version)[:2]

        if flow_version == version.FLOW_FORMAT_VERSION:
            break
        elif flow_version in converters:
            flow_data = converters[flow_version](flow_data)
        else:
            should_upgrade = (
                isinstance(flow_version, int)
                and flow_version > version.FLOW_FORMAT_VERSION
            )
            raise ValueError(
                "{} cannot read files with flow format version {}{}.".format(
                    version.MITMPROXY,
                    flow_version,
                    ", please update mitmproxy" if should_upgrade else ""
                )
            )
    return flow_data
